import sys
import os
import xmltodict
import pprint
import json
import xml.etree.ElementTree as ET
from bs4 import BeautifulSoup
import simplejson
from lxml import etree
from io import StringIO, BytesIO
import unicodedata
import re
import pandas as pd
import numpy as np
from random import randint
from mlxtend.preprocessing import TransactionEncoder
from ast import literal_eval


BENIGN='benign'
MALWARE='malware'


def get_malware_family_count(malwares):
    unique_malwares=[]

    for malware in malwares:
        for each_mal in malware:
            if each_mal not in unique_malwares:
                unique_malwares.append(each_mal)
    return len(unique_malwares)

def get_malware_tokenizer(malfamilies):
    encoding_dictionary={'BENIGN':0}
    opcode=1
    for each_entry in malfamilies:
        for each_family in each_entry[0]:
            if each_family not in encoding_dictionary:
                encoding_dictionary[each_family]=opcode
                opcode=opcode+1

    return encoding_dictionary

def malware_tokenize(malfamily,malfamilydict):
    tokenized=[]
    for each in malfamily[0]:
        tokenized.append(malfamilydict[each])
    return tokenized

def make_dataset(api_call_sequences_benign,api_call_sequences_malware,malfamilies):
    total_entries=len(api_call_sequences_benign)+len(api_call_sequences_malware)
    df_final_data=pd.DataFrame(columns=['API_CALL_SEQ','VERDICT','FAMILY'])
    malfamilydict=get_malware_tokenizer(malfamilies)
    for index in range(len(api_call_sequences_benign)):
        df_final_data.loc[index]=[api_call_sequences_benign[index],0,[]]
        print(index)

    for index in range(len(api_call_sequences_malware)):
        df_final_data.loc[index+len(api_call_sequences_benign)]=[api_call_sequences_malware[index],1,malware_tokenize(malfamilies[index],malfamilydict)]
        print(index+len(api_call_sequences_benign))

    df_final_data=df_final_data.sample(frac=1).reset_index(drop=True)

    return df_final_data

def get_max_api_call_length(api_call_sequences_benign,api_call_sequences_malware):
    max_api_call_length=0
    for each_call_sequence in api_call_sequences_benign:
        if len(each_call_sequence)>max_api_call_length:
            max_api_call_length=len(each_call_sequence)
    for each_call_sequence in api_call_sequences_malware:
        if len(each_call_sequence)>max_api_call_length:
            max_api_call_length=len(each_call_sequence)
    return max_api_call_length



def remove_control_characters(s):
    print(type(s))
    #return ''.join(c for c in s if ord(c) >= 32)
    return "".join(ch for ch in s if unicodedata.category(ch)[0]!="C")



def validate_params(received_param,allowable_params_list):
    if(received_param in allowable_params_list):
        return True

    print('Parameter Received: ',received_param)
    print('Allowable Parameters: ',allowable_params_list)
    return False



def print_current_dir():
    print('Currently in directory:',os.getcwd())



def extract_api_calls(nature):

    if not validate_params(nature,[BENIGN,MALWARE]):
        return ''

    print_current_dir()
    #os.chdir(nature)
    #print_current_dir()

    #full_sequence={'sequence':[]}
    full_sequence2=[]
    final_sequence=[]

    if nature=='benign':
        file_name='benign_samples.json'
    else:
        file_name='malware_samples.json'

    with open(file_name) as fd:
        d=json.load(fd)
    breaker=0
    full_sequence2=[]
    family_labels=[]
    for each_entry in d:
        path=each_entry['da_xml_file_path']
        if(path==''):
            continue
        if not os.path.exists(path):
            continue
        family_label=each_entry['mal_family_labels']
        subseq=[]
        print('-----------------------------------------------------------------------------------------')
        print('FILE : ',path)

        parser = etree.XMLParser(recover=True)
        tree = etree.parse(path,parser=parser)
        root = tree.getroot()
        xmlstring=etree.tostring(tree.getroot())
        xmsltring=remove_control_characters(str(xmlstring))




        for susp_act in root.iter('Suspicious_Action_Monitored'):
            sequence=susp_act.attrib['Action']
            print('SEQ:',sequence)
            subseq.append(sequence)

        full_sequence2.append(subseq)
        family_labels.append(family_label)




    print('SEQUENCES EXTRACTED')



    fname='api_call_sequences_'+nature

    final_file=open(fname,'w')
    simplejson.dump(full_sequence2,final_file)

    return fname,family_labels



def read_api_calls_from_file(file_name):

    with open(file_name,'r') as fd:
        data=fd.read()

    data=data[1:]

    data=re.sub('[\]]',']#',data)

    data=data.split('#')
    del data[-1]
    del data[-1]

    extracted_sequence=[]

    for every_entry in data:


        if every_entry[0]==',':
            every_entry=every_entry[2:]

        every_entry=re.sub('[\]\[]','',every_entry)

        each_call=every_entry.split('\"')
        print('LENEC:',len(each_call))
        each_call_cleaned=[]
        for i in range(len(each_call)):
            if each_call[i]=='' or each_call[i]==', ':
                pass
            else:
                each_call_cleaned.append(each_call[i])


        extracted_sequence.append(each_call_cleaned)



    return extracted_sequence


def generate_tokenizer(ben_call_list,mal_call_list):
    encoding_dictionary={'NO CALL':0}
    opcode=1
    for each_call_sequence in ben_call_list:
        for each_call in each_call_sequence:
            if each_call not in encoding_dictionary:
                encoding_dictionary[each_call]=opcode
                opcode=opcode+1
    for each_call_sequence in mal_call_list:
        for each_call in each_call_sequence:
            if each_call not in encoding_dictionary:
                encoding_dictionary[each_call]=opcode
                opcode=opcode+1

    return encoding_dictionary

def tokenize(ben_call_list,mal_call_list):
    encoding_dictionary=generate_tokenizer(ben_call_list,mal_call_list)
    ben_call_list_tokenized=[]
    mal_call_list_tokenized=[]
    for each_call_sequence in ben_call_list:
        each_call_sequence_tokenized=[]
        for each_call in each_call_sequence:
            each_call_sequence_tokenized.append(encoding_dictionary[each_call])
        ben_call_list_tokenized.append(list(each_call_sequence_tokenized))

    for each_call_sequence in mal_call_list:
        each_call_sequence_tokenized=[]
        for each_call in each_call_sequence:
            each_call_sequence_tokenized.append(encoding_dictionary[each_call])
        mal_call_list_tokenized.append(list(each_call_sequence_tokenized))

    return ben_call_list_tokenized,mal_call_list_tokenized

def get_sequences(tokenized=False):
    ''' Function to be used by main program if needed'''
    benigncalls='api_call_sequences_benign'
    malcalls='api_call_sequences_malware'
    ben_call_list=read_api_calls_from_file(benigncalls)
    mal_call_list=read_api_calls_from_file(malcalls)
    if tokenized:
        tokenize(ben_call_list,mal_call_list)
    return ben_call_list,mal_call_list

def generate_dataset_csv(reload_files=False):
    if reload_files:
        benigncalls,beningnfamilies=extract_api_calls(BENIGN)
        malcalls,malfamilies=extract_api_calls(MALWARE)
    else:
        benigncalls='api_call_sequences_benign'
        malcalls='api_call_sequences_malware'

    ben_call_list=read_api_calls_from_file(benigncalls)
    mal_call_list=read_api_calls_from_file(malcalls)

    ben_call_list_tokenized,mal_call_list_tokenized=tokenize(ben_call_list,mal_call_list)

    dataset=make_dataset(ben_call_list_tokenized,mal_call_list_tokenized,malfamilies)
    dataset.to_csv('dataset.csv')





def get_data(reload_files=False,astr=False):
    if not os.path.exists('DATA/dataset.csv'):
        generate_dataset_csv(True)
    df=pd.read_csv('DATA/dataset.csv')
    df=df.drop('Unnamed: 0',axis=1)

    print(df.head())

    X=df['API_CALL_SEQ'].values
    Y=df['VERDICT'].values
    Z=df['FAMILY'].values


    X2=[]
    Z2=[]
    if astr:
        for x in X:
            if x[0]!='[':
                print(x)
            x=literal_eval(x)
            X2.append(x)

        for z in Z:
            z2=literal_eval(z)
            Z2.append(z2)

        return X2,Y,Z2
    return X,Y,Z

#_,_=get_data()
